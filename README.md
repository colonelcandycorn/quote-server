# Quote Server
## Creator: Sarah Dylan

## Project Description
The goal of this project is to create a full stack website that presents quotes to the user. 

In class, we used sqlx, but I wanted to get more experience using an ORM or to get a feel for how ORM's work in Rust. I have limited experience using Django and SqlAlchemy/Alembic in Python projects so it was very interesting comparing my previous experiences to my time with SeaOrm. Overall, I was pretty impressed with how straightforward SeaOrm felt. It was relatively straightforward to access data from the database and post data to the database. The main thing that I found most challenging about SeaOrm was creating migrations. While I found the documentation more than adequate for using the ORM, I found the documentation for how to write migrations using their library very confusing. It took a lot googling and searching to get my migrations to work the way I expected. In the end, however, I ended up having to resort to some vanilla SQL in the last migration because I could not figure out how to perform the actions I needed in the libraries syntax.

A lot of my inspiration was from [SeaOrm's Axum Example](https://github.com/SeaQL/sea-orm/tree/master/examples/axum_example). I noticed that they created separate lib crates for each part of the project(entity, service, migration...). This made some sense to me as migration is forced to be a separate crate by SeaOrm, and the setup looks nice. From this, I learned about workspaces, which was interesting.

I did also realize that I am not particularly good at implementing design patterns. I've seen the concept how differentiating between data transfer objects (DTO's) and data access objects (DAO's) but I am not sure I really followed their spirit in my implementation. I didn't want to pass around the raw database model around the backend so I created structs like "QuoteDTO" to pass around, but this kind of ended up getting confused when I realized the data that creates a new quote would be different from the data needed by the "QuoteDTO" so I ended up with objects like "QuoteCreateDTO". I do think separating DataAccess functions to it's own module worked out well. 

Templates were good for testing out the DataAccess functions I wrote, and implementing the API was just a matter of copying the code over from the template functions and instead returning JSON. Utoipa was about as easy it could be without it being autogenerated for you. I was surprised how easy it was to get the '/swagger-ui' route set up.

## Running the Server

1. **Specify the SQLite database location.**  
You can use the default name `quotes_server.db`, or provide a custom name:

    ```bash
    cargo run -- -d <custom_name>.db
    ```

    > *Note: The database must be located at the root of the project.*

2. **Seed the database with data.**  
There is a form where you can add quotes manually or you can choose to seed your data with a file that contains
an array of quotes conforming to the QuoteCreateDTO

    ```bash
    cargo run -- -i
    ```

3. **Start the server.**  
Running the project will serve the website at [http://127.0.0.1:3000](http://127.0.0.1:3000).

4. **View templates**
By default you'll be routed to the templated version of '/quotes'. 

5. **View API**
All of the json api routes are the same as the templates except for the fact they prefixed by '/api' so '/quotes' becomes '/api/quotes'.
To view the swagger ui just go to [/swagger-ui](http://127.0.0.1:3000/swagger-ui)

## Current State of the Website

- Quote Template  
![A screenshot showing the template at /quote](<static/assets/template_quote.png>)
- Quote API Response  
![A screenshot showing the api response at /api/quote](<static/assets/api_quote.png>)
- Swagger UI  
![A screenshot showing the Swagger UI docs](<static/assets/swagger.png>)